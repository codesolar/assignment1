# -*- coding: utf-8 -*-
"""Untitled10.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Pxh6LXlxDDZ3b_zeiawA8ylnLyaxbytb
"""

# -*- coding: utf-8 -*-
"""Untitled8.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dgfaa9LfQ4liFe1swov3CiT-p9WaMDlf
"""

#used to work with arrays
import numpy as np
#used to import dataset
import pandas as pd
# used for plotting the dataset
import matplotlib.pyplot as plt
#used for largest value 
import sys

#google drive link of dataset 
url="https://drive.google.com/file/d/1vOxV1dIc0JKOu--I9g8ufQ7D3iBaD01_/view?usp=sharing"
url='https://drive.google.com/uc?id=' + url.split('/')[-2]

#used the dataset url to import dataset
dataframe=pd.read_csv(url,names=["X1","X2"])
print("first 5 rows of data=")
print(dataframe.head())

#transposing the data frame and storing it in X.
X=dataframe.T

#making X as a numpy array.
X=np.array(X)
X_non_centered=X
#printing shape of dataset
X.shape

#X dataframe has 2 features and 1000 data frames. “n”  is the number of data points and number of features are stored in “number_of_features”
n=len(X[0])
number_of_features=len(X)

#This function is for implementing PCA 
def PCA(X):
  #computing covariance matrix
  covariance_matrix=np.dot(X,X.T)*(1/n)
  #finding eigen vectors and eigen values of covarinace matrix
  eigenvalues,eigenvectors=np.linalg.eigh(covariance_matrix)

  #getting the sum of eigen values
  sum_of_eigenvalues=0
  for eigenvalue in eigenvalues:
    sum_of_eigenvalues+=eigenvalue


  #sorting the eigen values and eigen vectors
  order=np.argsort(eigenvalues,axis=0)[::-1]
  eigenvalues=eigenvalues[order]
  eigenvectors=eigenvectors[:,order]

  
  print("The eigenvector and eigenvalues in decreasing order:")
  for i in range(len(eigenvalues)):
    print("eigenvector={0} and eigenvalue={1:.2f}".format(eigenvectors[:,i],eigenvalues[i]))
    print("percentage of variance maintained by this eigenvalue is={:.2f}%".format(100*(eigenvalues[i]/sum_of_eigenvalues)))
  return eigenvalues,eigenvectors

#function for plotting the graph 
def plot(X):
  X1=[]
  X2=[]
  for i in range(len(X[0])):
    X1.append(X[0][i])
    X2.append(X[1][i])
  plt.figure(figsize=(8,8)) 
  plt.plot(X1,X2,'ro')
  plt.xlabel('X1')
  plt.ylabel('X2')
  plt.grid()
  plt.legend(["datapoints"])
  plt.title("Original Dataset")
  plt.show()


#data centering
def data_centering(X):
  mu=(1/n)*np.sum(X,axis=1)
  mu=mu.reshape(number_of_features,1)
  X=X-mu
  return X,mu
#function for plotting the graph with the eigen vectors
def PCA_plot(X,eigenvectors):
  X1=[]
  X2=[]
#.At first I have created two lists X1 and X2 and as every data point is of 2 features , for every data point I have stored the features in X1 and X2 lists respectively
  for i in range(len(X[0])):
    X1.append(X[0][i])
    X2.append(X[1][i])

  #plotting the figure
  plt.figure(figsize=(8,8))
  plt.plot(X1,X2,'ro')

 #two lists for storing x and y component of eigen vector
  eigenvector_X_component=[]
  eigenvector_Y_component=[]

  #computing slope of the eigen vector and drawiing the line
  for i in range(len(eigenvectors[0])):
    slope=eigenvectors[1][i]/eigenvectors[0][i]
    eigenvector_X_component=np.linspace(-10,8,100)
    eigenvector_Y_component=slope*eigenvector_X_component
    plt.plot(eigenvector_X_component,eigenvector_Y_component,'-')
    plt.ylim(-10,10)
    eigenvector_X_component=[]
    eigenvector_Y_component=[] 


  #labeling x and y component
  plt.xlabel('X1')
  plt.ylabel('X2')
  plt.legend(['datapoints','PC1','PC2'])
  #plotting grid line 
  plt.grid()
  plt.title("Original Dataset")
  plt.show()


print("plot after data centering")
X,mu=data_centering(X)
plot(X)

#running the PCA and finding eigen vectors and eigen values
eigenvalues,eigenvectors=PCA(X)

#plotting the graph
PCA_plot(X,eigenvectors)







print("plot without data centering")
#plotting the graph
plot(X_non_centered)

#finding eigenvectors and eigen value on the centered dataset
eigenvalues,eigenvectors=PCA(X_non_centered)
#plotting the graph
PCA_plot(X_non_centered,eigenvectors)

print("mean is =")
print(mu)
print("mean is very small , so centering does not help")




#code for making kernel matrix
def poly_kernel(X,d):
  kernel_matrix=[]
  for i in range(len(X[0])):
    l=[]
    for j in range(len(X[0])):
      x=[]
      y=[]
      x.append(X[0][i])
      x.append(X[1][i])
      y.append(X[0][j])
      y.append(X[1][j])

      #using kernel function on the two vectors x and y
      ans=np.power((np.dot(x,y)+1),d)
      l.append(ans)
    kernel_matrix.append(l)
  return kernel_matrix

#kernel matrix centering part
def kernel_centering(kernel_matrix):
  one_n=[]
  for i in range(n):
    l=[]
    for j in range(n):
      l.append(1/n)
    one_n.append(l)

  kernel_centered=kernel_matrix-np.dot(one_n,kernel_matrix)-np.dot(kernel_matrix,one_n)+np.dot(np.dot(one_n,kernel_matrix),one_n)

  return kernel_centered

#code for getting the coefficients of each point on the eigen vectors
def get_coefficients(kernel_matrix):
  coefficients=[]

  #finding eigenvectors and eigenvalue of the kernel matrix
  eigenvalues,eigenvectors=np.linalg.eigh(kernel_matrix)
  #sorting the eigenvalues and eigenvectors in the order of decreasing order of eigenvalues
  order=np.argsort(eigenvalues,axis=0)[::-1]
  eigenvalues=eigenvalues.real
  eigenvalues=eigenvalues[order]
  eigenvectors=eigenvectors[:,order]


  #taking the eigenvectors corresponding to the top 2 eigen values
  for i in range(2):
    eigenvector=eigenvectors[:,i]

    #finding alpha from beta
    alpha=eigenvector/np.sqrt(eigenvalues[i])

    #finding coefficients along the principal components(eigen vectors)
    coeff=[]
    for row in kernel_matrix:
      row=np.array(row)
      coeff.append(np.dot(row.T,alpha))
    coefficients.append(coeff)
  return coefficients

#plotting the coefficients
def plot_coefficients(x,y,string):
  plt.figure(figsize=(8,8)) 
  plt.scatter(x,y)

  #giving x and y labels
  plt.xlabel("1st principal component")
  plt.ylabel("2nd principal component")
  plt.legend(['datapoints'])
  plt.title(string)
  plt.show()




#running pca for kernel matrix with polynomial kernel of degree 2
kernel_matrix=poly_kernel(X,2)
#centering the kernel matrix
kernel_matrix=kernel_centering(kernel_matrix)
#getting coefficients along the 1st and 2nd principal components
coefficients=get_coefficients(kernel_matrix)
#plotting the coefficients along the components 
string ="Polynomial Kernel with degree=2"
plot_coefficients(coefficients[0],coefficients[1],string)





##running pca for kernel matrix with polynomial kernel of degree 2
kernel_matrix=poly_kernel(X,3)

##centering the kernel matrix
kernel_matrix=kernel_centering(kernel_matrix)

##getting coefficients along the 1st and 2nd principal components
coefficients=get_coefficients(kernel_matrix)
string ="Polynomial Kernel with degree=3"
#plotting the coefficients along the components 
plot_coefficients(coefficients[0],coefficients[1],string)





#sigma values in a list
sigmas=np.arange(0.1,1.1,0.1)
sigmas=tuple(sigmas)

#doing PCA with RBF kernel 
fig,axs=plt.subplots(5,2,figsize=(16,40))
index=0

for i in range(5):
  for j in range(2):
    sigma=sigmas[index]
    index+=1
    kernel_matrix=[]
    sigma_squared=sigma**2

    #code for making kernel matrix
    for p in range(len(X[0])):
      l=[]
      for q in range(len(X[0])):
        x=[]
        y=[]
        x.append(X[0][p])
        x.append(X[1][p])
        y.append(X[0][q])
        y.append(X[1][q])
        x=np.array(x)
        y=np.array(y)
        ans=np.exp(-np.dot((x-y).T,(x-y))/(2*sigma_squared))
        l.append(ans)
      kernel_matrix.append(l)

    #code for centering the kernel matrix  
    kernel_matrix=kernel_centering(kernel_matrix)
    coefficients=get_coefficients(kernel_matrix)

    #plotting the coefficients along the 2 principal components
    axs[i][j].scatter(coefficients[0],coefficients[1])
    axs[i][j].set_title("RBF kernel with sigma={:.1f}".format(sigma))
    axs[i][j].legend(['Datapoints'])
    axs[i][j].set_xlabel("1st principal component")
    axs[i][j].set_ylabel("2nd principal component")